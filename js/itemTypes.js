//oncreate, leftuse, rightuse, ondropped, ondelete, onpickup
game.itemTypes = {
  stone: [function (){}, function (entityPos, raycastPos, object){}, function (entityPos, raycastPos, object){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "stone", true); this.use()}}, function (){}, function (){}, function (){}],
  plant: [function (){}, function (entityPos, raycastPos, object){}, function (entityPos, raycastPos, object){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "plant", true); this.use()}}, function (){}, function (){}, function (){}],
  wood: [function (){}, function (entityPos, raycastPos, object){}, function (entityPos, raycastPos, object){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "wood", true); this.use()}}, function (){}, function (){}, function (){}],
  dirt: [function (){}, function (entityPos, raycastPos, object){}, function (entityPos, raycastPos, object){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "dirt", true); this.use()}}, function (){}, function (){}, function (){}],
  tree: [function (){}, function (entityPos, raycastPos, object){}, function (entityPos, raycastPos, object){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "tree", true); this.use()}}, function (){}, function (){}, function (){}],
  mud: [function (){}, function (entityPos, raycastPos, object){}, function (entityPos, raycastPos, object){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "mud", true); this.use()}}, function (){}, function (){}, function (){}],
  world_barrier: [function (){}, function (entityPos, raycastPos, object){}, function (entityPos, raycastPos, object){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "world_barrier", true); this.use()}}, function (){}, function (){}, function (){}],
  bricks: [function (){}, function (entityPos, raycastPos, object){}, function (entityPos, raycastPos, object){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "bricks", true); this.use()}}, function (){}, function (){}, function (){}],
  meat: [function (){}, function (){}, function (){if(this.inventory.object.health==this.inventory.object.maxHealth){return}; this.inventory.object.health += 40; game.UI.sound("eat"); this.use(); }, function (){}, function (){}, function (){}],
};