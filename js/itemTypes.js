//oncreate, leftuse, rightuse, ondropped, ondelete, onpickup
game.itemTypes = {
  stone: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "stone", true); this.use()}}, function (){}, function (){}, function (){}],
  plant: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "plant", true); this.use()}}, function (){}, function (){}, function (){}],
  wood: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "wood", true); this.use()}}, function (){}, function (){}, function (){}],
  dirt: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "dirt", true); this.use()}}, function (){}, function (){}, function (){}],
  tree: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "tree", true); this.use()}}, function (){}, function (){}, function (){}],
  mud: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "mud", true); this.use()}}, function (){}, function (){}, function (){}],
  world_barrier: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "world_barrier", true); this.use()}}, function (){}, function (){}, function (){}],
  bricks: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "bricks", true); this.use()}}, function (){}, function (){}, function (){}],
  meat: [function (){}, function (){}, function (){if(this.inventory.object.health==this.inventory.object.maxHealth){return}; this.inventory.object.health += 40; game.UI.sound("eat"); this.use(); }, function (){}, function (){}, function (){}],
  sword: [function (){},function (entityPos, raycastPos, object, entity){if(game.attackCooldown){return}; game.UI.swing.src=game.UI.swing.src; var old = entity.attackDamage; entity.attackDamage=12; game.UI.sound("sword"+Math.floor(Math.random()*2+1)); setTimeout("game.attackCooldown = true",10); setTimeout(function(){entity.attackDamage=old;game.attackCooldown = false;}, 800)},function (entityPos, raycastPos, object, entity){},function (){},function (){},function (){}],
};