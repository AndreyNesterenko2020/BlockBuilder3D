//oncreate, leftuse, rightuse, ondropped, ondelete, onpickup, heldTexture
game.itemTypes = {
  stone: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "stone", true); this.use()}}, function (){}, function (){}, function (){}, "stone", {}],
  plant: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "plant", true); this.use()}}, function (){}, function (){}, function (){}, "plant", {}],
  wood: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "wood", true); this.use()}}, function (){}, function (){}, function (){}, "wood", {}],
  dirt: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "dirt", true); this.use()}}, function (){}, function (){}, function (){}, "dirt", {}],
  tree: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "tree", true); this.use()}}, function (){}, function (){}, function (){}, "tree", {}],
  mud: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "mud", true); this.use()}}, function (){}, function (){}, function (){}, "mud", {}],
  world_barrier: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "world_barrier", true); this.use()}}, function (){}, function (){}, function (){}, "world_barrier", {}],
  bricks: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "bricks", true); this.use()}}, function (){}, function (){}, function (){}, "bricks", {}],
  meat: [function (){}, function (){}, function (){if(this.inventory.object.health==this.inventory.object.maxHealth){return}; this.inventory.object.health += 30; game.UI.sound("eat"); this.use(); }, function (){}, function (){}, function (){}, "meat", {}],
  sword: [function (){},function (entityPos, raycastPos, object, entity){if(entity.entityData.attackCooldown){return}; game.UI.swing.src=game.UI.swing.src; var old = entity.attackDamage; entity.attackDamage=12; game.UI.sound("sword"+Math.floor(Math.random()*2+1)); setTimeout(function(){entity.entityData.attackCooldown = true},10); setTimeout(function(){entity.attackDamage=old;entity.entityData.attackCooldown = false;}, 800)},function (entityPos, raycastPos, object, entity){},function (){},function (){},function (){}, "sword_held", {}],
  fat: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "fat", true); this.use()}}, function (){}, function (){}, function (){}, "fat", {}],
  stonebricks: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "stonebricks", true); this.use()}}, function (){}, function (){}, function (){}, "stonebricks", {}],
  planks: [function (){}, function (entityPos, raycastPos, object, entity){}, function (entityPos, raycastPos, object, entity){if(entityPos.distanceTo(raycastPos) <= game.range && !object.entity){if(entityPos.equals(raycastPos)){return}; new game.block(raycastPos.x, raycastPos.y, raycastPos.z, "planks", true); this.use()}}, function (){}, function (){}, function (){}, "planks", {}],
  chicken: [function (){}, function (){}, function (){if(this.inventory.object.health==this.inventory.object.maxHealth){return}; this.inventory.object.health += 25; game.UI.sound("eat"); this.use(); }, function (){}, function (){}, function (){}, "chicken", {}],
  pickaxe: [function (){}, function (){}, function (){}, function (){}, function (){}, function (){}, "pickaxe_held", {"stone": 0.5, "stonebricks": 0.5, "bricks": 0.5}],
};